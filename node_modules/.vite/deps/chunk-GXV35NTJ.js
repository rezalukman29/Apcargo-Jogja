import {
  PanSession,
  callAllHandlers,
  contains,
  detectBrowser,
  focus,
  getActiveElement,
  getAllFocusable,
  getBox,
  getOwnerDocument,
  getOwnerWindow,
  getPointerEventName,
  hasFocusWithin,
  isActiveElement,
  isBrowser,
  isRefObject,
  isTabbable,
  noop,
  runIfFn,
  wrapPointerEventHandler
} from "./chunk-6NVFBBHT.js";
import {
  require_react
} from "./chunk-IXG3QTAX.js";
import {
  __commonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy2(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e) {
          e.stopPropagation();
          if (options.format) {
            e.preventDefault();
            if (typeof e.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e.clipboardData.clearData();
              e.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e.preventDefault();
            options.onCopy(e.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy2;
  }
});

// node_modules/@chakra-ui/hooks/dist/use-animation-state-5054a9f7.esm.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var useSafeLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;
function useCallbackRef(fn, deps) {
  if (deps === void 0) {
    deps = [];
  }
  var ref = React.useRef(fn);
  useSafeLayoutEffect(function() {
    ref.current = fn;
  });
  return React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current.apply(ref, args);
  }, deps);
}
function useEventListener(event, handler, env, options) {
  var listener = useCallbackRef(handler);
  React.useEffect(function() {
    var _runIfFn;
    var node = (_runIfFn = runIfFn(env)) != null ? _runIfFn : document;
    if (!handler) {
      return;
    }
    node.addEventListener(event, listener, options);
    return function() {
      node.removeEventListener(event, listener, options);
    };
  }, [event, env, options, listener, handler]);
  return function() {
    var _runIfFn2;
    var node = (_runIfFn2 = runIfFn(env)) != null ? _runIfFn2 : document;
    node.removeEventListener(event, listener, options);
  };
}
function useAnimationState(props) {
  var isOpen = props.isOpen, ref = props.ref;
  var _useState = (0, import_react.useState)(isOpen), mounted = _useState[0], setMounted = _useState[1];
  var _useState2 = (0, import_react.useState)(false), once = _useState2[0], setOnce = _useState2[1];
  (0, import_react.useEffect)(function() {
    if (!once) {
      setMounted(isOpen);
      setOnce(true);
    }
  }, [isOpen, once, mounted]);
  useEventListener("animationend", function() {
    setMounted(isOpen);
  }, function() {
    return ref.current;
  });
  var hidden = isOpen ? false : !mounted;
  return {
    present: !hidden,
    onComplete: function onComplete() {
      var _ref$current;
      var win = getOwnerWindow(ref.current);
      var evt = new win.CustomEvent("animationend", {
        bubbles: true
      });
      (_ref$current = ref.current) == null ? void 0 : _ref$current.dispatchEvent(evt);
    }
  };
}

// node_modules/@chakra-ui/hooks/dist/chakra-ui-hooks.esm.js
var React2 = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
function useBoolean(initialState) {
  if (initialState === void 0) {
    initialState = false;
  }
  var _useState = (0, import_react2.useState)(initialState), value = _useState[0], setValue = _useState[1];
  var callbacks = (0, import_react2.useMemo)(function() {
    return {
      on: function on() {
        return setValue(true);
      },
      off: function off() {
        return setValue(false);
      },
      toggle: function toggle() {
        return setValue(function(prev) {
          return !prev;
        });
      }
    };
  }, []);
  return [value, callbacks];
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["timeout"];
function useClipboard(text, optionsOrTimeout) {
  if (optionsOrTimeout === void 0) {
    optionsOrTimeout = {};
  }
  var _useState = (0, import_react2.useState)(false), hasCopied = _useState[0], setHasCopied = _useState[1];
  var _ref = typeof optionsOrTimeout === "number" ? {
    timeout: optionsOrTimeout
  } : optionsOrTimeout, _ref$timeout = _ref.timeout, timeout = _ref$timeout === void 0 ? 1500 : _ref$timeout, copyOptions = _objectWithoutPropertiesLoose(_ref, _excluded);
  var onCopy = (0, import_react2.useCallback)(function() {
    var didCopy = (0, import_copy_to_clipboard.default)(text, copyOptions);
    setHasCopied(didCopy);
  }, [text, copyOptions]);
  (0, import_react2.useEffect)(function() {
    var timeoutId = null;
    if (hasCopied) {
      timeoutId = window.setTimeout(function() {
        setHasCopied(false);
      }, timeout);
    }
    return function() {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value: text,
    onCopy,
    hasCopied
  };
}
function useConst(init) {
  var ref = (0, import_react2.useRef)(null);
  if (ref.current === null) {
    ref.current = typeof init === "function" ? init() : init;
  }
  return ref.current;
}
function useControllableProp(prop, state) {
  var isControlled = prop !== void 0;
  var value = isControlled && typeof prop !== "undefined" ? prop : state;
  return [isControlled, value];
}
function useControllableState(props) {
  var valueProp = props.value, defaultValue = props.defaultValue, onChange = props.onChange, _props$shouldUpdate = props.shouldUpdate, shouldUpdate = _props$shouldUpdate === void 0 ? function(prev, next) {
    return prev !== next;
  } : _props$shouldUpdate;
  var onChangeProp = useCallbackRef(onChange);
  var shouldUpdateProp = useCallbackRef(shouldUpdate);
  var _React$useState = React2.useState(defaultValue), valueState = _React$useState[0], setValue = _React$useState[1];
  var isControlled = valueProp !== void 0;
  var value = isControlled ? valueProp : valueState;
  var updateValue = React2.useCallback(function(next) {
    var nextValue = runIfFn(next, value);
    if (!shouldUpdateProp(value, nextValue)) {
      return;
    }
    if (!isControlled) {
      setValue(nextValue);
    }
    onChangeProp(nextValue);
  }, [isControlled, onChangeProp, value, shouldUpdateProp]);
  return [value, updateValue];
}
function useDimensions(ref, observe) {
  var _React$useState = React2.useState(null), dimensions = _React$useState[0], setDimensions = _React$useState[1];
  var rafId = React2.useRef();
  useSafeLayoutEffect(function() {
    if (!ref.current)
      return void 0;
    var node = ref.current;
    function measure() {
      rafId.current = requestAnimationFrame(function() {
        var boxModel = getBox(node);
        setDimensions(boxModel);
      });
    }
    measure();
    if (observe) {
      window.addEventListener("resize", measure);
      window.addEventListener("scroll", measure);
    }
    return function() {
      if (observe) {
        window.removeEventListener("resize", measure);
        window.removeEventListener("scroll", measure);
      }
      if (rafId.current) {
        cancelAnimationFrame(rafId.current);
      }
    };
  }, [observe]);
  return dimensions;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var defaultIdContext = {
  current: 1
};
var IdContext = React2.createContext(defaultIdContext);
var IdProvider = React2.memo(function(_ref) {
  var children = _ref.children;
  return React2.createElement(IdContext.Provider, {
    value: {
      current: 1
    }
  }, children);
});
var genId = function genId2(context) {
  return context.current++;
};
function useId(idProp, prefix) {
  var context = React2.useContext(IdContext);
  var _React$useState = React2.useState(context.current), id = _React$useState[0], setId = _React$useState[1];
  React2.useEffect(function() {
    setId(genId(context));
  }, [context]);
  return React2.useMemo(function() {
    return idProp || [prefix, id].filter(Boolean).join("-");
  }, [idProp, prefix, id]);
}
function useIds(idProp) {
  for (var _len = arguments.length, prefixes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    prefixes[_key - 1] = arguments[_key];
  }
  var id = useId(idProp);
  return React2.useMemo(function() {
    return prefixes.map(function(prefix) {
      return prefix + "-" + id;
    });
  }, [id, prefixes]);
}
function useOptionalPart(partId) {
  var _React$useState2 = React2.useState(null), id = _React$useState2[0], setId = _React$useState2[1];
  var ref = React2.useCallback(function(node) {
    setId(node ? partId : null);
  }, [partId]);
  return {
    ref,
    id,
    isRendered: Boolean(id)
  };
}
function useDisclosure(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, onCloseProp = _props.onClose, onOpenProp = _props.onOpen, isOpenProp = _props.isOpen, idProp = _props.id;
  var onOpenPropCallbackRef = useCallbackRef(onOpenProp);
  var onClosePropCallbackRef = useCallbackRef(onCloseProp);
  var _React$useState = React2.useState(props.defaultIsOpen || false), isOpenState = _React$useState[0], setIsOpen = _React$useState[1];
  var _useControllableProp = useControllableProp(isOpenProp, isOpenState), isControlled = _useControllableProp[0], isOpen = _useControllableProp[1];
  var id = useId(idProp, "disclosure");
  var onClose = React2.useCallback(function() {
    if (!isControlled) {
      setIsOpen(false);
    }
    onClosePropCallbackRef == null ? void 0 : onClosePropCallbackRef();
  }, [isControlled, onClosePropCallbackRef]);
  var onOpen = React2.useCallback(function() {
    if (!isControlled) {
      setIsOpen(true);
    }
    onOpenPropCallbackRef == null ? void 0 : onOpenPropCallbackRef();
  }, [isControlled, onOpenPropCallbackRef]);
  var onToggle = React2.useCallback(function() {
    var action = isOpen ? onClose : onOpen;
    action();
  }, [isOpen, onOpen, onClose]);
  return {
    isOpen: !!isOpen,
    onOpen,
    onClose,
    onToggle,
    isControlled,
    getButtonProps: function getButtonProps(props2) {
      if (props2 === void 0) {
        props2 = {};
      }
      return _extends({}, props2, {
        "aria-expanded": "true",
        "aria-controls": id,
        onClick: callAllHandlers(props2.onClick, onToggle)
      });
    },
    getDisclosureProps: function getDisclosureProps(props2) {
      if (props2 === void 0) {
        props2 = {};
      }
      return _extends({}, props2, {
        hidden: !isOpen,
        id
      });
    }
  };
}
function useEventCallback(callback) {
  var ref = React2.useRef(callback);
  useSafeLayoutEffect(function() {
    ref.current = callback;
  });
  return React2.useCallback(function(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return ref.current.apply(ref, [event].concat(args));
  }, []);
}
function useEventListenerMap() {
  var listeners = React2.useRef(/* @__PURE__ */ new Map());
  var currentListeners = listeners.current;
  var add = React2.useCallback(function(el, type, listener, options) {
    var pointerEventListener = wrapPointerEventHandler(listener, type === "pointerdown");
    listeners.current.set(listener, {
      __listener: pointerEventListener,
      type: getPointerEventName(type),
      el,
      options
    });
    el.addEventListener(type, pointerEventListener, options);
  }, []);
  var remove = React2.useCallback(function(el, type, listener, options) {
    var _listeners$current$ge = listeners.current.get(listener), pointerEventListener = _listeners$current$ge.__listener;
    el.removeEventListener(type, pointerEventListener, options);
    listeners.current["delete"](pointerEventListener);
  }, []);
  React2.useEffect(function() {
    return function() {
      currentListeners.forEach(function(value, key) {
        remove(value.el, value.type, key, value.options);
      });
    };
  }, [remove, currentListeners]);
  return {
    add,
    remove
  };
}
var useUpdateEffect = function useUpdateEffect2(effect, deps) {
  var mounted = React2.useRef(false);
  React2.useEffect(function() {
    if (mounted.current) {
      return effect();
    }
    mounted.current = true;
    return void 0;
  }, deps);
  return mounted.current;
};
function useFocusEffect(ref, options) {
  var shouldFocus = options.shouldFocus, preventScroll = options.preventScroll;
  useUpdateEffect(function() {
    var node = ref.current;
    if (!node || !shouldFocus)
      return;
    if (!hasFocusWithin(node)) {
      focus(node, {
        preventScroll,
        nextTick: true
      });
    }
  }, [shouldFocus, ref, preventScroll]);
}
function preventReturnFocus(containerRef) {
  var el = containerRef.current;
  if (!el)
    return false;
  var activeElement = getActiveElement(el);
  if (!activeElement)
    return false;
  if (contains(el, activeElement))
    return false;
  if (isTabbable(activeElement))
    return true;
  return false;
}
function useFocusOnHide(containerRef, options) {
  var shouldFocusProp = options.shouldFocus, visible = options.visible, focusRef = options.focusRef;
  var shouldFocus = shouldFocusProp && !visible;
  useUpdateEffect(function() {
    if (!shouldFocus)
      return;
    if (preventReturnFocus(containerRef)) {
      return;
    }
    var el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
    if (el) {
      focus(el, {
        nextTick: true
      });
    }
  }, [shouldFocus, containerRef, focusRef]);
}
function usePointerEvent(env, eventName, handler, options) {
  return useEventListener(getPointerEventName(eventName), wrapPointerEventHandler(handler, eventName === "pointerdown"), env, options);
}
function useFocusOnPointerDown(props) {
  var ref = props.ref, elements = props.elements, enabled = props.enabled;
  var isSafari = detectBrowser("Safari");
  var doc = function doc2() {
    return getOwnerDocument(ref.current);
  };
  usePointerEvent(doc, "pointerdown", function(event) {
    if (!isSafari || !enabled)
      return;
    var target = event.target;
    var els = elements != null ? elements : [ref];
    var isValidTarget = els.some(function(elementOrRef) {
      var el = isRefObject(elementOrRef) ? elementOrRef.current : elementOrRef;
      return contains(el, target);
    });
    if (!isActiveElement(target) && isValidTarget) {
      event.preventDefault();
      focus(target);
    }
  });
}
var defaultOptions = {
  preventScroll: true,
  shouldFocus: false
};
function useFocusOnShow(target, options) {
  if (options === void 0) {
    options = defaultOptions;
  }
  var _options = options, focusRef = _options.focusRef, preventScroll = _options.preventScroll, shouldFocus = _options.shouldFocus, visible = _options.visible;
  var element = isRefObject(target) ? target.current : target;
  var autoFocus = shouldFocus && visible;
  var onFocus = (0, import_react2.useCallback)(function() {
    if (!element || !autoFocus)
      return;
    if (contains(element, document.activeElement))
      return;
    if (focusRef != null && focusRef.current) {
      focus(focusRef.current, {
        preventScroll,
        nextTick: true
      });
    } else {
      var tabbableEls = getAllFocusable(element);
      if (tabbableEls.length > 0) {
        focus(tabbableEls[0], {
          preventScroll,
          nextTick: true
        });
      }
    }
  }, [autoFocus, preventScroll, element, focusRef]);
  useUpdateEffect(function() {
    onFocus();
  }, [onFocus]);
  useEventListener("transitionend", onFocus, element);
}
function useUnmountEffect(fn, deps) {
  if (deps === void 0) {
    deps = [];
  }
  return React2.useEffect(
    function() {
      return function() {
        return fn();
      };
    },
    deps
  );
}
function useForceUpdate() {
  var unloadingRef = React2.useRef(false);
  var _React$useState = React2.useState(0), count = _React$useState[0], setCount = _React$useState[1];
  useUnmountEffect(function() {
    unloadingRef.current = true;
  });
  return React2.useCallback(function() {
    if (!unloadingRef.current) {
      setCount(count + 1);
    }
  }, [count]);
}
function useInterval(callback, delay) {
  var fn = useCallbackRef(callback);
  React2.useEffect(function() {
    var intervalId = null;
    var tick = function tick2() {
      return fn();
    };
    if (delay !== null) {
      intervalId = window.setInterval(tick, delay);
    }
    return function() {
      if (intervalId) {
        window.clearInterval(intervalId);
      }
    };
  }, [delay, fn]);
}
function useLatestRef(value) {
  var ref = React2.useRef(null);
  ref.current = value;
  return ref;
}
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error("Cannot assign value '" + value + "' to ref '" + ref + "'");
  }
}
function useMergeRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return React2.useMemo(function() {
    if (refs.every(function(ref) {
      return ref == null;
    })) {
      return null;
    }
    return function(node) {
      refs.forEach(function(ref) {
        if (ref)
          assignRef(ref, node);
      });
    };
  }, refs);
}
function useMouseDownRef(shouldListen) {
  if (shouldListen === void 0) {
    shouldListen = true;
  }
  var mouseDownRef = import_react2.default.useRef();
  useEventListener("mousedown", function(event) {
    if (shouldListen) {
      mouseDownRef.current = event.target;
    }
  });
  return mouseDownRef;
}
function useOutsideClick(props) {
  var ref = props.ref, handler = props.handler, _props$enabled = props.enabled, enabled = _props$enabled === void 0 ? true : _props$enabled;
  var savedHandler = useCallbackRef(handler);
  var stateRef = (0, import_react2.useRef)({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  var state = stateRef.current;
  (0, import_react2.useEffect)(function() {
    if (!enabled)
      return;
    var onPointerDown = function onPointerDown2(e) {
      if (isValidEvent(e, ref)) {
        state.isPointerDown = true;
      }
    };
    var onMouseUp = function onMouseUp2(event) {
      if (state.ignoreEmulatedMouseEvents) {
        state.ignoreEmulatedMouseEvents = false;
        return;
      }
      if (state.isPointerDown && handler && isValidEvent(event, ref)) {
        state.isPointerDown = false;
        savedHandler(event);
      }
    };
    var onTouchEnd = function onTouchEnd2(event) {
      state.ignoreEmulatedMouseEvents = true;
      if (handler && state.isPointerDown && isValidEvent(event, ref)) {
        state.isPointerDown = false;
        savedHandler(event);
      }
    };
    var doc = getOwnerDocument(ref.current);
    doc.addEventListener("mousedown", onPointerDown, true);
    doc.addEventListener("mouseup", onMouseUp, true);
    doc.addEventListener("touchstart", onPointerDown, true);
    doc.addEventListener("touchend", onTouchEnd, true);
    return function() {
      doc.removeEventListener("mousedown", onPointerDown, true);
      doc.removeEventListener("mouseup", onMouseUp, true);
      doc.removeEventListener("touchstart", onPointerDown, true);
      doc.removeEventListener("touchend", onTouchEnd, true);
    };
  }, [handler, ref, savedHandler, state, enabled]);
}
function isValidEvent(event, ref) {
  var _ref$current;
  var target = event.target;
  if (event.button > 0)
    return false;
  if (target) {
    var doc = getOwnerDocument(target);
    if (!doc.body.contains(target))
      return false;
  }
  return !((_ref$current = ref.current) != null && _ref$current.contains(target));
}
function usePanGesture(ref, props) {
  var onPan = props.onPan, onPanStart = props.onPanStart, onPanEnd = props.onPanEnd, onPanSessionStart = props.onPanSessionStart, onPanSessionEnd = props.onPanSessionEnd, threshold = props.threshold;
  var hasPanEvents = Boolean(onPan || onPanStart || onPanEnd || onPanSessionStart || onPanSessionEnd);
  var panSession = (0, import_react2.useRef)(null);
  var handlers = {
    onSessionStart: onPanSessionStart,
    onSessionEnd: onPanSessionEnd,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: function onEnd(event, info) {
      panSession.current = null;
      onPanEnd == null ? void 0 : onPanEnd(event, info);
    }
  };
  (0, import_react2.useEffect)(function() {
    var _panSession$current;
    (_panSession$current = panSession.current) == null ? void 0 : _panSession$current.updateHandlers(handlers);
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, threshold);
  }
  usePointerEvent(function() {
    return ref.current;
  }, "pointerdown", hasPanEvents ? onPointerDown : noop);
  useUnmountEffect(function() {
    var _panSession$current2;
    (_panSession$current2 = panSession.current) == null ? void 0 : _panSession$current2.end();
    panSession.current = null;
  });
}
function usePrevious(value) {
  var ref = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(function() {
    ref.current = value;
  }, [value]);
  return ref.current;
}
function isPrintableCharacter(event) {
  var key = event.key;
  return key.length === 1 || key.length > 1 && /[^a-zA-Z0-9]/.test(key);
}
function useShortcut(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, _props$timeout = _props.timeout, timeout = _props$timeout === void 0 ? 300 : _props$timeout, _props$preventDefault = _props.preventDefault, preventDefault = _props$preventDefault === void 0 ? function() {
    return true;
  } : _props$preventDefault;
  var _React$useState = React2.useState([]), keys = _React$useState[0], setKeys = _React$useState[1];
  var timeoutRef = React2.useRef();
  var flush = function flush2() {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
  var clearKeysAfterDelay = function clearKeysAfterDelay2() {
    flush();
    timeoutRef.current = setTimeout(function() {
      setKeys([]);
      timeoutRef.current = null;
    }, timeout);
  };
  React2.useEffect(function() {
    return flush;
  }, []);
  function onKeyDown(fn) {
    return function(event) {
      if (event.key === "Backspace") {
        var keysCopy = [].concat(keys);
        keysCopy.pop();
        setKeys(keysCopy);
        return;
      }
      if (isPrintableCharacter(event)) {
        var _keysCopy = keys.concat(event.key);
        if (preventDefault(event)) {
          event.preventDefault();
          event.stopPropagation();
        }
        setKeys(_keysCopy);
        fn(_keysCopy.join(""));
        clearKeysAfterDelay();
      }
    };
  }
  return onKeyDown;
}
function useTimeout(callback, delay) {
  var fn = useCallbackRef(callback);
  React2.useEffect(function() {
    if (delay == null)
      return void 0;
    var timeoutId = null;
    timeoutId = window.setTimeout(function() {
      fn();
    }, delay);
    return function() {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [delay, fn]);
}
function useWhyDidYouUpdate(name, props) {
  var previousProps = React2.useRef();
  React2.useEffect(function() {
    if (previousProps.current) {
      var allKeys = Object.keys(_extends({}, previousProps.current, props));
      var changesObj = {};
      allKeys.forEach(function(key) {
        if (previousProps.current[key] !== props[key]) {
          changesObj[key] = {
            from: previousProps.current[key],
            to: props[key]
          };
        }
      });
      if (Object.keys(changesObj).length) {
        console.log("[why-did-you-update]", name, changesObj);
      }
    }
    previousProps.current = props;
  });
}

export {
  useSafeLayoutEffect,
  useCallbackRef,
  useEventListener,
  useAnimationState,
  useBoolean,
  useClipboard,
  useConst,
  useControllableProp,
  useControllableState,
  useDimensions,
  IdProvider,
  useId,
  useIds,
  useOptionalPart,
  useDisclosure,
  useEventCallback,
  useEventListenerMap,
  useUpdateEffect,
  useFocusEffect,
  useFocusOnHide,
  usePointerEvent,
  useFocusOnPointerDown,
  useFocusOnShow,
  useUnmountEffect,
  useForceUpdate,
  useInterval,
  useLatestRef,
  assignRef,
  useMergeRefs,
  useMouseDownRef,
  useOutsideClick,
  usePanGesture,
  usePrevious,
  useShortcut,
  useTimeout,
  useWhyDidYouUpdate
};
//# sourceMappingURL=chunk-GXV35NTJ.js.map
